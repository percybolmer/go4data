// Package databases is generated by Handlergenerator tooling
// Make sure to insert real Description here
package databases

import (
	"context"
	"fmt"

	"github.com/percybolmer/workflow/metric"
	"github.com/percybolmer/workflow/payload"
	"github.com/percybolmer/workflow/property"
	"github.com/percybolmer/workflow/pubsub"
	"github.com/percybolmer/workflow/register"

	"github.com/percybolmer/elasticlogger"
)

// PutElasticSearch is used to push payloads onto a elasticsearch topic
type PutElasticSearch struct {
	// Cfg is values needed to properly run the Handle func
	Cfg *property.Configuration `json:"configs" yaml:"configs"`
	// Name is sort of like an ID used to load data back should be the same that is used to register the Handler
	Name string `json:"handler_name" yaml:"handler_name"`
	// subscriptionless should be set to true if this Handler does not need any input payloads to function
	subscriptionless bool
	// the index to push onto
	index string
	// the ip of the elastic node
	ip string
	// the port of the elastic
	port   int
	system string
	//errChan is the channel to output errors.
	errChan chan error
	// metrics is a metric.Provider that allows export of metrics
	metrics metric.Provider
	// metricPrefix is a unique string to attach to metrics
	metricPrefix string
	// eslogger is used to log to escluster
	eslogger *elasticlogger.ElasticLog
}

func init() {
	register.Register("PutElasticSearch", NewPutElasticSearchHandler())
}

// NewPutElasticSearchHandler generates a new PutElasticSearch Handler
func NewPutElasticSearchHandler() *PutElasticSearch {
	act := &PutElasticSearch{
		Cfg: &property.Configuration{
			Properties: make([]*property.Property, 0),
		},
		Name:    "PutElasticSearch",
		errChan: make(chan error, 1000),
	}
	act.Cfg.AddProperty("index", "the index to push to", true)
	act.Cfg.AddProperty("ip", "the ip of the elasticserver to connect", true)
	act.Cfg.AddProperty("port", "the port used by the server", true)
	return act
}

// GetHandlerName should return the name of the handler that was used in register
func (a *PutElasticSearch) GetHandlerName() string {
	return a.Name
}

// Handle is used to send the payload []byte to an index as a JSON
func (a *PutElasticSearch) Handle(ctx context.Context, input payload.Payload, topics ...string) error {
	a.metrics.IncrementMetric(fmt.Sprintf("%s_payloads_in", a.metricPrefix), 1)
	_, err := a.eslogger.Write(input.GetPayload())
	if err != nil {
		return err
	}

	if len(topics) != 0 {
		pubsub.PublishTopics(topics, input)
	}
	return nil
}

// ValidateConfiguration is used to see that all needed configurations are assigned before starting
func (a *PutElasticSearch) ValidateConfiguration() (bool, []string) {
	// Check if Cfgs are there as needed
	valid, miss := a.Cfg.ValidateProperties()
	if !valid {
		return valid, miss
	}

	indexProp := a.Cfg.GetProperty("index")
	index := indexProp.String()
	if index == "" {
		return false, []string{"cannot have an empty index"}
	}

	ipProp := a.Cfg.GetProperty("ip")
	ip := ipProp.String()

	portProp := a.Cfg.GetProperty(("port"))
	port, err := portProp.Int()
	if err != nil {
		return false, []string{err.Error()}
	}

	a.ip = ip
	a.port = port
	a.index = index

	es, err := elasticlogger.NewElasticLogger(ip, int16(port), index)
	if err != nil {
		return false, []string{err.Error()}
	}
	a.eslogger = es
	return true, nil
}

// GetConfiguration will return the CFG for the Handler
func (a *PutElasticSearch) GetConfiguration() *property.Configuration {
	return a.Cfg
}

// Subscriptionless will return true/false if the Handler is genereating payloads itself
func (a *PutElasticSearch) Subscriptionless() bool {
	return a.subscriptionless
}

// GetErrorChannel will return a channel that the Handler can output eventual errors onto
func (a *PutElasticSearch) GetErrorChannel() chan error {
	return a.errChan
}

// SetMetricProvider is used to change what metrics provider is used by the handler
func (a *PutElasticSearch) SetMetricProvider(p metric.Provider, prefix string) error {
	a.metrics = p
	a.metricPrefix = prefix

	// Here you can add Metrics that you want to be stored, should return error if the metric collides with another metric from ANY handler.
	err := a.metrics.AddMetric(&metric.Metric{
		Name:        fmt.Sprintf("%s_payloads_in", prefix),
		Description: "keeps track of how many payloads the handler has ingested",
	})
	return err

}
