// Package terminalprocessors is generated by generate-processor tooling
// Make sure to insert real Description here
package terminalprocessors

import (
	"context"
	"fmt"

	"github.com/percybolmer/workflow/failure"
	"github.com/percybolmer/workflow/metric"
	"github.com/percybolmer/workflow/processors/processmanager"
	"github.com/percybolmer/workflow/properties"
	"github.com/percybolmer/workflow/relationships"
)

// Stdout is print the payload to stdout
type Stdout struct {
	Name                    string `json:"name" yaml:"name"`
	running                 bool
	cancel                  context.CancelFunc
	ingress                 relationships.PayloadChannel
	egress                  relationships.PayloadChannel
	failures                relationships.FailurePipe
	*properties.PropertyMap `json:"properties,omitempty" yaml:"properties,omitempty"`
	*metric.Metrics         `json:"metrics,omitempty" yaml:",inline,omitempty"`

	forward bool
}

// init is used to Register the processor to the processmanager
func init() {
	err := processmanager.RegisterProcessor("Stdout", NewStdoutInterface)
	if err != nil {
		panic(err)
	}
}

// NewStdoutInterface is used to return the Proccssor as interface
// This is to avoid Cyclic imports, we are not allowed to return processors.Processor
// so, let processmanager deal with the type assertion
func NewStdoutInterface() interface{} {
	return NewStdout()
}

// NewStdout is used to initialize and generate a new processor
func NewStdout() *Stdout {
	proc := &Stdout{
		egress:      make(relationships.PayloadChannel, 1000),
		PropertyMap: properties.NewPropertyMap(),
		Metrics:     metric.NewMetrics(),
		Name:        "Stdout",
	}

	proc.AddAvailableProperty("forward", "Set to true if payload should be sent to the next processor")
	// Add Required Props -- remove_after
	//proc.AddRequirement("your_property_names")
	return proc
}

// GetName returns the unique name of the processor
func (proc *Stdout) GetName() string {
	return proc.Name
}

// Initialize will make sure all needed Properties and Metrics are generated
func (proc *Stdout) Initialize() error {

	// Make sure Properties are there
	ok, _ := proc.ValidateProperties()
	if !ok {
		return properties.ErrRequiredPropertiesNotFulfilled
	}

	// See if the Payloads that is sendt here should be forwarded
	forProp := proc.GetProperty("forward")
	if forProp != nil {
		b, err := forProp.Bool()
		if err != nil {
			return err
		}
		proc.forward = b
	}

	return nil
}

// Start will spawn a goroutine that reads file and Exits either on Context.Done or When processing is finished
func (proc *Stdout) Start(ctx context.Context) error {
	if proc.running {
		return failure.ErrAlreadyRunning
	}
	// Uncomment if u need to Processor to require an Ingress relationship
	if proc.ingress == nil {
		return failure.ErrIngressRelationshipNeeded
	}

	proc.running = true
	// context will be used to spawn a Cancel func
	c, cancel := context.WithCancel(ctx)
	proc.cancel = cancel
	go func() {
		for {
			select {
			case payload := <-proc.ingress:
				proc.AddMetric("payloads-printed", "a number of how many payloads has been printed", 1)
				fmt.Println(payload.GetPayload())

				if proc.forward {
					proc.egress <- payload
				}
			case <-c.Done():
				return
			}
		}
	}()
	return nil
}

// IsRunning will return true or false based on if the processor is currently running
func (proc *Stdout) IsRunning() bool {
	return proc.running
}

// GetMetrics will return a bunch of generated metrics, or nil if there isn't any
func (proc *Stdout) GetMetrics() []*metric.Metric {
	return proc.GetAllMetrics()
}

// SetFailureChannel will configure the failure channel of the Processor
func (proc *Stdout) SetFailureChannel(fp relationships.FailurePipe) {
	proc.failures = fp
}

// Stop will stop the processing
func (proc *Stdout) Stop() {
	if !proc.running {
		return
	}
	proc.running = false
	proc.cancel()
}

// SetIngress will change the ingress of the processor, Restart is needed before applied changes
func (proc *Stdout) SetIngress(i relationships.PayloadChannel) {
	proc.ingress = i
	return
}

// GetEgress will return an Egress that is used to output the processed items
func (proc *Stdout) GetEgress() relationships.PayloadChannel {
	return proc.egress
}
